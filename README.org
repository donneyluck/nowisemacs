* Introduction to nowisemacs
Nowisemacs is a configuration framework for GNU Emacs that tends to be used in everyday scenarios with a wealth of
features but on an easy-to-maintain
basis.

It's designed by following principles:
+ *Close to metal*. As a core idea of nowisemacs, there should be less between users and vanilla emacs.
+ *Easy to use and modify*.
  Generally, the
  higher degree of abstraction, the stronger the applicability of programs. But the abstraction will increase the
  distance between users and native codes and make it more difficult for users to maintain codes. Nowiemacs trys to solve this problems in two ways:
  1. Nowisemacs uses a tiling scheme to avoid high level code abstraction, and uses an org-structure to combine all
     components to avoid the code confusion caused by the tile scheme. Thus, nowisemacs separate the code structure and
     functional structure. Users are supposed to focus only on the functional structure when using it, and focus only on code structure
     when modifying code.
  2. Nowisemacs provides many simple macros to simplify the daily configuration of users. With the help of =setup=, users
     can quickly handle the configuration cycle of a new or existing package. At the same time, users are encouraged to get the real native code
     everywhere by using =emacs-lisp-macroexpand=.
** Features
+ Affected by lazycat-emacs, there is a clear process chain in nowisemacs
+ Writing on the fly with a full configured org-mode, includes beautiful interfaces, a deep integration with org-roam
  and org-agenda, many useful English auxiliary writing tools and so on.
+ Universal programming solution including completion, jump, search under different path or files. With the help of *Language Server Protocol* powered by Microsoft and the great ctags
  front-end *citre*, users can easily use and expand almost all programming languages under emacs.
** Ideas behind nowisemacs
*** TL ; NR
Concise + High maintainability
*** Description in detail
**** Understand Emacs from the perspective of system architecture
1. Emacs can be regarded as a virtual machine of the lisp language. And the core function of a virtual machine is to
   manage memory.
2. The built-in variables and functions defined by Emacs are set together with the user-defined functions, and they are
   all equivalent as First-class citizen.
3. Therefore, most of the user's operation on Emacs correspond to a function, and users can modify all external or
   built-in variables and functions. In other words, users should regard themselves as internal schedulers of the
   system, not external users.
**** Packages and related configurations should be simple
Simplicity doesn't mean that the number of packages used is few, or the interface is ugly, but that the following
concepts should be met as far as possible:
1. Try to use built-in functions to reduce redundancy. The rational use of these APIs can greatly reduce the external
   maintenance burden.
2. Packages should be designed simple and flexible, which will reduce dependencies.
3. Packages with less code or active updates will have higher priority.
4. Try to use the default configuration or select packages with enough default configuration to avoid the update burden
   caused by numerous hacks.
**** Easy to maintain
I like rich functionality, which allows me to have suitable solutions for various scenarios. Usually adding a functionality
will increase the complexity of configurations. Nowisemacs looks for a balance between functionality and complexity by
"concise" choices.
** How to use
Nowisemacs uses a single org file to manage all configurations. To reduce the startup time of emacs, users need to
generate =.el= configuration files before the first startup:
1. =mv ~/.emacs.d/ .emacs.d.back= ;; Backup your original configuration
2. =mkdir ~/.emacs.d= ;; Make the emacs configuration folder.
3. =git clone https://github.com/nowislewis/nowisemacs ~/nowisemacs=;; Download nowisemacs
4. =emacs ~/nowisemacs/init.org= ;; Open init.org
5. Sequentially press "Ctrl-c Ctrl-v t", or ~Alt-x~ =org-babel-tangle= to generate init.el
6. =emacs= ;; Launch emacs, the download, installation and configuration of packages will be done automatically.
* Things you must know before going deeper
** Radical
1. Nowisemacs uses the latest emacs repo and compile it locally, so there may be some incompatible when you use an older version.
2. Fast iteration, no option of "all" packages. If there is a package with a cleaner code implementation than the one
   used now, or fewer dependencies, or better functionality, only *one* will be left.
** Sacrifice for simplicity
The code will be kept iteratively updated and thus less stable, because any duplicated or useless code will be
   updated or optimized immediately, with little consideration for compatibility.
** Beginners are encouraged to access package website
Many functions provided by packages are invoked manually as APIs with =M-x= with few key bindings. Users are encouraged to
access the website of packages to get a comprehensive understanding.
* Optinal reading
** Why setup instead of simpler manual configuration or full-blown use-package?
As mentioned above, nowisemacs hoped to reduce the abstraction level of configuration as much as possible while meeting
practical requirements, so as they facilitate the understanding of configuration maintenance code.

After heavy use for a period of time, I gave up use-package and leaf. They have a high degree of abstraction and thus
complex mechanisms, which is not conducive to understanding and debugging.

At the suggestion of Lazycat, a great Emacs contributor, I have used the native way to configure Emacs for a while. I
really like this idea, it is clear and easy to drill down. No black box here.

But if you use the native way, you will find that there is a lot of duplicated codes, which make the work tedious and
increase the maintenance work. =setup= comes into view. First, =setup= is almost indistinguishable from the native
way at the level of abstraction. =setup= is actually a bunch of simple macros to generate code. And the code generated
after macro-expand is almost the same as native methods. So =setup= is also clear and easy to drill down as native way.

The function of =setup= is to turn these repeated codes into simple calls, which are equivalent to defining one place, but
can be used everywhere.
* Related great solutions
+ [[https://github.com/hlissner/doom-emacs][doom emacs]]
+ [[https://github.com/manateelazycat/lazycat-emacs][lazycat-emacs]]
+ [[https://github.com/seagle0128/.emacs.d][centaur emacs]]
